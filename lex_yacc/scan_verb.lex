%{
    /**
     * 这个例子演示了非常简单的识别
     * 动词/非动词
     */

    /**
     * {% %}为定义部分，定义一个段，介绍了将拷贝到最终程序中的
     * 原始C程序代码。也就是说这一部分的内容C程序里面是可以使用
     * 的。如果有后来文件中必须包含的头文件，那么也需要在这里面
     * 包含。其中，{% %}里面的内容使用C实现，lex将其中的内容直接
     * 拷贝到生成的C文件。
     *
     * lex中的注释必须使用空白符缩进来正确标识，否则将会被lex
     * 解释成别的东西。
     * 后面的%%标记这一部分结束
     * 下面一部分是规则段，每个规则都有两部分组成，模式和动作，
     * 由空白分开。当lex生成的词法分析程序识别出某个模式时，将
     * 执行相应的动作，其中模式是unix样式的正则表达式
     */

    /**
     * 规则"|"表示下一个模式应用相同的动作，因此所有的
     * 动词都使用为最后一个动词指定的动作
     *
     * island为什么不匹配is而是匹配island或者是两者都匹配呢？
     *
     * yytext数组包含匹配模式的文本
     * lex有一套简单的消除歧义规则：
     * 1：lex模式只匹配输入字符或字符串一次
     * 2：lex执行当前输入的最长可能匹配的动作。
     * 因为lsland是比is长的匹配u，所以lex把island
     * 来看做匹配上面那条“包括一切”的规则
     *
     * 最后一行是默认情况语句。"."匹配换行符意外的任意单个字符，
     * "\n"匹配一个换行符，ECHO输出匹配的模式。
     *
     * 最后部分是用户子例程序，有任意合法的C代码组成。
     * 
     * 使用命令进行编译
     * lex simple.lex  //生成lex.yy.c
     * gcc lex.yy.c -o simple
     *
     */
%}

%%
[\t ]+  /* 忽略空白 */;
is |
am |
are |
were |
was |
be |
being |
been |
do |
does |
did |
will |
would |
should |
can |
could |
has |
have |
had |
go  {printf("%s : is a verb\n",yytext);}

[a-zA-Z]+   {printf("%s: is not a verb\n",yytext);}

.|\n    {ECHO; /* 通常的默认状态 */}
%%

int main()
{
    yylex();
    return 0;
}

//必须要包含的函数
int yywrap()
{
    return 1;
}

